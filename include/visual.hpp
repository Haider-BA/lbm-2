#pragma once

namespace lbm
{
namespace io
{

namespace
{
template <typename lattice_model>
std::string compute_coordinates(const Domain<lattice_model>& domain)
{
    auto xl = domain.xlength();
    auto yl = domain.ylength();
    auto zl = domain.zlength();
    /* Print lattice points */
     double xs = domain.xspacing();
     double ys = domain.yspacing();
     double zs = domain.zspacing();
     double xo = domain.xorigin();
     double yo = domain.yorigin();
     double zo = domain.zorigin();

     std::ostringstream str;
     for (auto z = 1u; z < zl + 1; ++z) {
         for (auto y = 1u; y < yl + 1; ++y) {
             for (auto x = 1u; x < xl + 1; ++x) {
                 str << xs*x+xo-1 << " " << ys*y+yo-1 << " " << zs*z+zo-1 << "\n";
             }
         }
     }
     return str.str();
}

}//anonymous namespace

#define VTS 1
template<typename lattice_model>
void write_vtk_file(const Domain<lattice_model>& domain, const std::string& output_dir,
        const std::string& output_filename, uint64_t t)
{
    auto xl = domain.xlength();
    auto yl = domain.ylength();
    auto zl = domain.zlength();
    // TODO: The following only holds for non-MPI executions. Check how to distinguish
    // Print lattice points. Since these are constant, we only need to compute them once.
    static const auto coordinates = compute_coordinates(domain);
    /* Save filename as a combination of passed filename and timestep */
    std::stringstream sstr;
    sstr << output_dir << "/" << output_filename << "." << t;
#if VTS
    sstr << ".vts";
#else
    sstr << ".vtk";
#endif
    std::ofstream file(sstr.str(), std::ios::trunc);

    if (!file) {
        std::cerr << "Failed to open file!" << std::endl;
        std::exit (EXIT_FAILURE);
    }
#if VTS
    file << "<?xml version=\"1.0\"?>\n";
    file << "<VTKFile type=\"StructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\">\n";
    file << "   <StructuredGrid WholeExtent=\"0 " << xl - 1 << " 0 " << yl - 1 << " 0 " << zl - 1
            << "\">\n";
    file << "   <Piece Extent=\"0 " << xl - 1 << " 0 " << yl - 1 << " 0 " << zl - 1 << "\" >\n";
    file << "       <PointData Scalars=\"density\" Vectors=\"velocity\">\n";
    /* ====================== Velocity ===================== */
    file << "           <DataArray Name=\"velocity\" type=\"Float32\" NumberOfComponents=\"3\" format=\"ascii\">\n";
#else
    file << "# vtk DataFile Version 2.0\n";
    file << "generated by CFD-lab course output\n";
    file << "ASCII\n";
    file << "\n";
    file << "DATASET STRUCTURED_GRID\n";
    file << "DIMENSIONS " << xl << ' ' << yl  << ' ' << zl  << "\n";
    file << "\nPOINTS " << (xl)*(yl)*(zl) << " float\n";
    file << coordinates << '\n';
    file << "POINT_DATA " << (xl )*(yl)*(zl ) << " \n";
    file << "\n";
    file << "VECTORS velocity float\n";
    file << "\n";
#endif
    /* Compute (macroscopic) velocities for all cells */
    std::vector<double> density(xl*yl*zl);
    auto index = 0u;
    #pragma omp for collapse(3)
    for (auto z = 1u; z < zl + 1; ++z) {
        for (auto y = 1u; y < yl + 1; ++y) {
            for (auto x = 1u; x < xl + 1; ++x) {
                auto current_cell = domain.cell(x, y, z);
                density[index] = current_cell.density();
                auto vel = current_cell.velocity(density[index]);
                file << vel[0] << " " << vel[1] << " " << vel[2] << "\n";
                ++index;
            }
        }
    }
#if VTS
    file << "           </DataArray>\n";
    /* ====================== Density ===================== */
    file << "           <DataArray Name=\"density\" type=\"Float32\">\n";
#else
    file << "\n";
    file << "SCALARS density float 1\n";
    file << "LOOKUP_TABLE default \n";
#endif
    /* Output density for each cell */
    for (auto i = 0u; i < density.size(); ++i) {
        file << density[i] << '\n';
    }
#if VTS
    file << "           </DataArray>\n";
    file << "       </PointData>\n";
    file << "       <CellData></CellData>\n";
    file << "       <Points>\n";
    /* ====================== Lattice points ===================== */
    file
            << "           <DataArray type=\"Float32\" Name=\"coordinate\" NumberOfComponents=\"3\" format=\"ascii\">\n";
    file << coordinates;
    file << "           </DataArray>\n";
    file << "       </Points>\n";
    file << "    </Piece>\n";
    file << "    </StructuredGrid>\n";
    file << "</VTKFile>\n";
#endif
    file.flush();
    file.close();
    if (!file) {
        std::cerr << "Failed to close file!" << std::endl;
        std::exit (EXIT_FAILURE);
    }
//        std::cout << "All elements written to \"" << sstr.str() << "\"." << std::endl;
}

template<typename lattice_model, typename solid_collision_model>
auto read_vtk_point_file(const std::string& filename,
        FluidCollision<lattice_model>& fluid_collision_model) -> Domain_ptr<lattice_model>
{
    vtkObject::GlobalWarningDisplayOff();
    auto reader = vtkSmartPointer<vtkDataSetReader>::New();

    reader->SetFileName(filename.c_str());

    reader->Update();
    if (!reader->IsFileValid("structured_points"))
        throw std::logic_error("VTK file \"" + filename + "\" does not exist or does not "
                "seem to be a valid structured grids file!");
    auto output = reader->GetOutput();
    if (output == nullptr) {
        // TODO: Improve exception handling
        throw std::logic_error("Could not read file!");
    }
    output->Register(reader);

    // Now check for point data
    auto dataset = reader->GetOutput();
    auto pd = dataset->GetPointData();

    Domain_ptr<lattice_model> domain;
    if (pd != nullptr) {
        auto p = dynamic_cast<vtkStructuredPoints*>(dataset);

        // Read Dimensions
        assert(p->GetDataDimension() == 3);
        int xl, yl, zl;
        xl = p->GetDimensions()[0];
        yl = p->GetDimensions()[1];
        zl = p->GetDimensions()[2];
        // Read Origins
        double ox, oy, oz;
        p->GetOrigin(ox, oy, oz);
        // Read Spacing
        double sx, sy, sz;
        p->GetSpacing(sx, sy, sz);
        // Create Domain
        domain = make_unique<Domain<lattice_model>>(xl, yl, zl, fluid_collision_model, ox, oy, oz, sx, sy, sz);
        // Get domain points
        auto points = dynamic_cast<vtkUnsignedCharArray*>(pd->GetArray(0));
//        auto solid_collision = std::make_shared<solid_collision_model>(*domain);
        static auto solid_collision = solid_collision_model(*domain);
        // Read only inner cells since we need to apply boundary conditions to the outer cells
        // Of course, we read the cells in a linear manner
        int index = 0;
        for (int z = 1; z < zl + 1; ++z) {
            for (int y = 1; y < yl + 1; ++y) {
                for (int x = 1; x < xl + 1; ++x) {
                    bool fluid = static_cast<bool>(points->GetValue(index++));
                    if (!fluid)
                        domain->cell(x, y, z).set_collision_handler(&solid_collision);
                }
            }
        }
    }
    else {
        dataset->Delete();
        throw std::logic_error("Point data is null!");
    }
    dataset->Delete();
    return std::move(domain);
}

} //namespace output
} //namespace lbm
